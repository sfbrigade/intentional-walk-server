import logging
import urllib

from django.test import Client, TestCase
from freezegun import freeze_time

from home.models import Contest, Device, Leaderboard
from home.utils.generators import (
    AccountGenerator,
    DeviceGenerator,
)


logger = logging.getLogger(__name__)


class TestLeaderboard(TestCase):
    def setUp(self):
        # Test client
        self.client = Client()

        # Device ID is passed to the API as "account_id",
        self.device_id = "12345"

        # Create a user
        response = self.client.post(
            path="/api/appuser/create",
            data={
                "name": "Abhay Kashyap",
                "email": "abhay@blah.com",
                "zip": "72185",
                "age": 99,
                "account_id": self.device_id,
            },
            content_type="application/json",
        )

        # Check for a successful response by the server
        self.assertEqual(response.status_code, 200)
        # Parse the response
        response_data = response.json()
        fail_message = f"Server response - {response_data}"
        self.assertEqual(response_data["status"], "success", msg=fail_message)
        self.assertEqual(
            response_data["message"],
            "Device registered & account registered successfully",
            msg=fail_message,
        )

        # Details for Daily walk event creation
        self.url = "/api/dailywalk/create"
        # Request parameters
        self.request_params = {
            "account_id": "12345",
            "daily_walks": [
                {"date": "3000-02-22", "steps": 500, "distance": 1.3}
            ],
        }
        self.bulk_request_params = {
            "account_id": "12345",
            "daily_walks": [
                {"date": "3000-02-21", "steps": 1500, "distance": 2.1},
                {"date": "3000-02-22", "steps": 500, "distance": 0.8},
                {"date": "3000-02-23", "steps": 1000, "distance": 1.4},
            ],
        }
        # Content type
        self.content_type = "application/json"

    # Test a successful creation of a daily walk (within a contest)
    # Test autogenerated Leaderboard entry with correct number of steps

    def test_create_dailywalk_and_leaderboard(self):
        # Create a contest
        contest = Contest()
        contest.start_baseline = "3000-01-01"
        contest.start_promo = "3000-02-01"
        contest.start = "3000-02-01"
        contest.end = "3000-02-28"
        contest.save()

        # Verify that the user has no contests
        acct = Device.objects.get(device_id=self.device_id).account
        self.assertFalse(acct.contests.exists())

        with freeze_time("3000-02-15"):
            # Send the request
            response = self.client.post(
                path=self.url,
                data=self.request_params,
                content_type=self.content_type,
            )
            # Check for a successful response by the server
            self.assertEqual(response.status_code, 200)
            # Parse the response
            response_data = response.json()
            fail_message = f"Server response - {response_data}"
            self.assertEqual(
                response_data["status"], "success", msg=fail_message
            )

            leaderboard_count = Leaderboard.objects.count()
            leaderboard_steps_count = Leaderboard.objects.get(
                device=self.device_id
            ).steps

            # Expected: 1 Leaderboard entry with 500 steps
            self.assertEqual(1, leaderboard_count)
            self.assertEqual(500, leaderboard_steps_count)

    # Leaderboard Get request test and data validation
    # Test that tester account is not included
    def test_get_leaderboard(self):

        accounts = list(AccountGenerator().generate(14))
        accounts[-1].is_tester = True
        accounts[-1].save()

        contest = Contest()
        contest.start_baseline = "3000-01-01"
        contest.start_promo = "3000-02-01"
        contest.start = "3000-02-01"
        contest.end = "3000-02-28"
        contest.save()

        # generate devices for the active accounts
        device1 = list(DeviceGenerator(accounts[1:2]).generate(1))
        device2 = list(DeviceGenerator(accounts[2:3]).generate(1))
        device3 = list(DeviceGenerator(accounts[3:4]).generate(1))
        device4 = list(DeviceGenerator(accounts[4:5]).generate(1))
        device5 = list(DeviceGenerator(accounts[5:6]).generate(1))
        device6 = list(DeviceGenerator(accounts[6:7]).generate(1))
        device7 = list(DeviceGenerator(accounts[7:8]).generate(1))
        device8 = list(DeviceGenerator(accounts[8:9]).generate(1))
        device9 = list(DeviceGenerator(accounts[9:10]).generate(1))
        device10 = list(DeviceGenerator(accounts[10:11]).generate(1))
        device11 = list(DeviceGenerator(accounts[11:12]).generate(1))
        device12 = list(DeviceGenerator(accounts[12:13]).generate(1))
        device13 = list(DeviceGenerator(accounts[13:14]).generate(1))

        # dwalks1 = DailyWalkGenerator(device1)
        # dwalks2 = DailyWalkGenerator(device2)
        # dwalks3 = DailyWalkGenerator(device3)
        # dwalks4 = DailyWalkGenerator(device4)
        # dwalks5 = DailyWalkGenerator(device5)
        # dwalks6 = DailyWalkGenerator(device6)
        # dwalks7 = DailyWalkGenerator(device7)
        # dwalks8 = DailyWalkGenerator(device8)
        # dwalks9 = DailyWalkGenerator(device9)
        # dwalks10 = DailyWalkGenerator(device10)
        # dwalks11 = DailyWalkGenerator(device11)
        # dwalks12 = DailyWalkGenerator(device12)

        # for dt in range(14):
        #     # Set dates on walks to 3000-02-28 to 3000-03-14
        #     t = utc.localize(datetime(3000, 2, 28, 10, 0)) + timedelta(days=dt)
        #     next(dwalks1.generate(1, date=t, steps=5000, distance=4000))
        #     next(dwalks2.generate(1, date=t, steps=10000, distance=8000))
        #     next(dwalks3.generate(1, date=t, steps=15000, distance=12000))
        #     next(dwalks4.generate(1, date=t, steps=5000, distance=4000))
        #     next(dwalks5.generate(1, date=t, steps=10000, distance=8000))
        #     next(dwalks6.generate(1, date=t, steps=15000, distance=12000))
        #     next(dwalks7.generate(1, date=t, steps=5000, distance=4000))
        #     next(dwalks8.generate(1, date=t, steps=10000, distance=8000))
        #     next(dwalks9.generate(1, date=t, steps=15000, distance=12000))
        #     next(dwalks10.generate(1, date=t, steps=5000, distance=4000))
        #     next(dwalks11.generate(1, date=t, steps=10000, distance=8000))
        #     next(dwalks12.generate(1, date=t, steps=15000, distance=12000))

        # Create 12 Leadeboard entries
        Leaderboard.objects.create(
            device=device1[0],
            contest=contest,
            account=accounts[1:2][0],
            steps=5,
        )
        Leaderboard.objects.create(
            device=device2[0],
            contest=contest,
            account=accounts[2:3][0],
            steps=10,
        )
        Leaderboard.objects.create(
            device=device3[0],
            contest=contest,
            account=accounts[3:4][0],
            steps=50,
        )
        Leaderboard.objects.create(
            device=device4[0],
            contest=contest,
            account=accounts[4:5][0],
            steps=200,
        )
        Leaderboard.objects.create(
            device=device5[0],
            contest=contest,
            account=accounts[5:6][0],
            steps=400,
        )
        Leaderboard.objects.create(
            device=device6[0],
            contest=contest,
            account=accounts[6:7][0],
            steps=800,
        )
        Leaderboard.objects.create(
            device=device7[0],
            contest=contest,
            account=accounts[7:8][0],
            steps=1200,
        )
        Leaderboard.objects.create(
            device=device8[0],
            contest=contest,
            account=accounts[8:9][0],
            steps=2000,
        )
        Leaderboard.objects.create(
            device=device9[0],
            contest=contest,
            account=accounts[9:10][0],
            steps=3000,
        )
        Leaderboard.objects.create(
            device=device10[0],
            contest=contest,
            account=accounts[10:11][0],
            steps=4000,
        )
        Leaderboard.objects.create(
            device=device11[0],
            contest=contest,
            account=accounts[11:12][0],
            steps=5000,
        )
        Leaderboard.objects.create(
            device=device12[0],
            contest=contest,
            account=accounts[12:13][0],
            steps=11000,
        )
        # Tester account, shouldn't be in output
        Leaderboard.objects.create(
            device=device13[0],
            contest=contest,
            account=accounts[13:14][0],
            steps=15000,
        )

        # Test Get request - Leaderboard
        self.client = Client()

        data = {
            "contest_id": contest.contest_id,
            "device_id": device10[0].device_id,
        }
        query = urllib.parse.urlencode(data)
        response = self.client.get("/api/leaderboard/get/?" + query)

        response_data = response.json()

        # Validate that tester account ({'account_id': 16, 'steps': 15000} isn't included)
        self.assertNotEqual(
            response_data["payload"]["leaderboard"][0]["steps"], 15000
        )

        # Validate 10 Leaderboard entries received as user is in top 10
        self.assertEqual(response.status_code, 200)
        listlength = len(response_data["payload"]["leaderboard"])
        self.assertEqual(listlength, 10)

        data = {
            "contest_id": contest.contest_id,
            "device_id": device2[0].device_id,
        }
        query = urllib.parse.urlencode(data)
        response = self.client.get("/api/leaderboard/get/?" + query)

        response_data_pretest = response.json()
        self.assertEqual(response.status_code, 200)

        # Validate 11 Leaderboard entries received as user is not in top 10
        listlength = len(response_data_pretest["payload"]["leaderboard"])
        self.assertEqual(listlength, 11)

        # Validate that data from before and after the contest period won't update the leaderboard;
        # and data during the contest will update the leaderboard

        self.url = "/api/dailywalk/create"

        # Request parameters
        self.request_params_before = {
            "account_id": device1[0].device_id,
            "daily_walks": [
                {"date": "3000-01-30", "steps": 5000, "distance": 1.3}
            ],
        }
        self.request_params_after = {
            "account_id": device2[0].device_id,
            "daily_walks": [
                {"date": "3000-03-01", "steps": 5000, "distance": 1.3}
            ],
        }

        self.request_params_during_fail = {
            "account_id": device2[0].device_id,
            "daily_walks": [
                {"date": "3000-02-15", "steps": 5000, "distance": 1.3}
            ],
        }

        # Daily walk added before contest start and after contest end
        # Before contest start:
        # Content type
        self.content_type = "application/json"

        # Send the request
        response = self.client.post(
            path=self.url,
            data=self.request_params_before,
            content_type=self.content_type,
        )
        # Check for a successful response by the server
        self.assertEqual(response.status_code, 200)
        # Parse the response
        response_data = response.json()
        fail_message = f"Server response - {response_data}"
        self.assertEqual(response_data["status"], "success", msg=fail_message)

        # After contest end:
        response = self.client.post(
            path=self.url,
            data=self.request_params_after,
            content_type=self.content_type,
        )
        # Check for a successful response by the server
        self.assertEqual(response.status_code, 200)
        # Parse the response
        response_data = response.json()
        fail_message = f"Server response - {response_data}"
        self.assertEqual(response_data["status"], "success", msg=fail_message)
        # Check if Leaderboard has changed,
        data = {
            "contest_id": contest.contest_id,
            "device_id": device2[0].device_id,
        }
        query = urllib.parse.urlencode(data)
        response = self.client.get("/api/leaderboard/get/?" + query)

        response_data = response.json()

        # Expected: Leaderboard is unchanged as dailywalks are outside contest period
        self.assertEqual(
            response_data["payload"]["leaderboard"],
            response_data_pretest["payload"]["leaderboard"],
        )
        self.assertEqual(response.status_code, 200)

        with freeze_time("3000-02-15"):
            # Dailywalk submitted during contest period
            response = self.client.post(
                path=self.url,
                data=self.request_params_during_fail,
                content_type=self.content_type,
            )
            # Check for a successful response by the server
            self.assertEqual(response.status_code, 200)
            # Parse the response
            response_data = response.json()
            fail_message = f"Server response - {response_data}"
            self.assertEqual(
                response_data["status"], "success", msg=fail_message
            )

        # Check if Leaderboard changes
        data = {
            "contest_id": contest.contest_id,
            "device_id": device2[0].device_id,
        }
        query = urllib.parse.urlencode(data)
        response = self.client.get("/api/leaderboard/get/?" + query)

        response_data = response.json()
        # Expected: Leaderboard has changed and is not equal to initial Leaderboard get request.
        self.assertNotEqual(
            response_data["payload"]["leaderboard"],
            response_data_pretest["payload"]["leaderboard"],
        )
        self.assertEqual(response.status_code, 200)
